[title Databases]

This chapter covers how you can work with Databases in a Moya project.

Most web applications use a [i]database[/i] to store [i]dynamic[/i] (changeable) data, required to implement standard features of a web site such as users logins, sessions, comments etc. Databases are so ubiquitous it is hard to imagine a feature that [i]doesn't[/i] need to use one.

Working with databases has traditionally meant writing [url http://en.wikipedia.org/wiki/SQL]SQL[/url] which -- although powerful -- has a fairly steep learning curve. Moya has it's own interface to databases which saves a lot of time in development and doesn't require you to work directly with SQL (although if you already know SQL it will be an advantage).

[aside]Moya gains it's database capabilities from [url http://www.sqlalchemy.org/]SQLAlchemy[/url], a powerful database toolkit. [aside]

[h1]Database Settings[/h1]

There are a number of settings Moya needs in order to connect to a database. To define a database, add a named section called [c]db[/c] with a name to identify the database in code. Here's an example of a database section in a settings file:

[code ini]
[db:main]
engine = sqlite:///basic.sqlite
default = yes
echo = no
[/code]

This tells Moya to connect to a database, which will be referred to by the name [c]main[/c] in code. The name of the database is only important if make use of multiple databases in your projects and you need to tell Moya which one you wish to work with. Most projects will only ever use one database, so a generic name like [c]main[/c] is probably a good choice. The following settings should be specified in the [c]db[/c] section:

[setting]engine = <engine>[/setting]

This tells Moya which kind if database you wish to connect to. See [link db#supported-databases]Supported Databases[/link] for what to specify here.

[setting]default = <yes/no>[/setting]

This tells Moya that the database should be the [i]default[/i], and should be used if you don't specify which database you are using in a database tags. This setting is only required if you have more than one database specified.

[setting]echo = <yes/no>[/setting]

When set to [c]yes[/c], Moya will write the SQL generated by database operations to the console. This can be helpful if you are debugging.

[h2]Multiple Databases[/h2]

You can specify as many databases as you need in your application (although its rare to have more than one). If you have multiple databases, you can specify which database to use with the [c]db[/c] attribute of database related tags. Otherwise Moya will use the database with [c]default[/c] set to [c]yes[/c].

[h1]Supported Databases[/h1]

Moya supports a number of different SQL databases which may be specified in the [c]engine[/c] setting. The format of [c]engine[/c] depends on the database you are using. This section lists the supported databases and how to construct the value of [c]engine[/c].

[aside]Installing and configuring a database isn't covered here. If you are unfamiliar with setting up a database, you should be able to find plenty of information on the internet to help you (it doesn't need to be Moya specific).[/aside]

[h2]SQLite[/h2]

SQLLite is a database that is contained entirely within a single file. SQLLite databases can be useful in development as they don't require installing any additional software, and if you need to start from scratch you can simply delete the database file. SQLLite databases are not often used for larger sites because it is not easy to share an SQLite database across multiple servers.

To specify an SQLLite database, set [c]engine[/c] to [c]sqllite:///[/c] followed by the filename of the sqllite database. Here's an example:

[code ini]
[db:main]
engine = sqlite:///example.sqlite
[/code]

This will store the database in a file called [c]example.sqlite[/c] (the extension is not important).

SQLite is the default for the [c]start project[/c] command -- if you want to get up and running quickly then you can leave the database setting unchanged. If you do need to connect to a database, then see one of the following sections:

[h2]MySQL[/h2]

To connect to a [url http://www.mysql.com/]MySQL[/url] database, use a value for [c]engine[/c] in the following format:

[code]
mysql://<user>:<password>@<host>/<database name>
[/code]

Here's an example:

[code ini]
[db:main]
engine = mysql://moya:muchsecret@localhost/moyaexample
[/code]

[h2]PostgresSQL[/h2]

Specifying a PostgresSQL database is similar to [link db#mysql]MySQL[/link]. The value for [c]engine[/c] should be in the following format:

[code]
postgres://<user>:<password>@<host>/<database name>
[/code]

[h2]Oracle[/h2]

To connect to an Oracle database, the value for [c]engine[/c] should be in the following format:

[code]
oracle://<user>:<password>@<host>/<database name>
[/code]

[h1]DB Command[/h1]

You can perform some database related tasks from the command line with the [c]db[/c] subcommand. This subcommand has a number of further subcommands. The following commandline will list the available db subcommands:

[code]
moya db -h
[/code]

We will cover database subcommands in this document.

[h1]Models[/h1]

A [i]model[/i] defines an object type which will be stored in a table in the database. Models contain a number of [i]fields[/i] which define the data associated with the model (text, number etc).

To create a model, use the [tag]model[/tag] tag in the [c]http://moyaproject.com/db[/c] namespace. It is customary to put your models in a file called [c]models.xml[/c], but you may want to split your models in to multiple files if you have many of them.

Let's look at an example of a simple model. The following defines a model with two string fields:

[code xml]
<moya>
    <model libname="Character" repr="character ${name}" xmlns="http://moyaproject.com/db">
        <string name="name" length="30" null="no"/>
        <string name="species" length="20" null="no" default="human" />
    </model>
</moya>
[/code]

Note the use of the [c]xmlns[/c] attribute which sets the namespace to [c]http://moyaproject.com/db[/c]. All database related tags are defined in this namespace. The [c]libname[/c] attribute has the same meaning as other tags in Moya, and is also used to identify the model in queries (see below).

The attribute [c]repr[/c] on a [tag db]model[/tag] tag tells Moya what to display when you print a model object to the console or log. It is not required, but can be very helpful during debugging.

Before we can use this model we must first create the tables in the database. We can do this with the following commandline:

[code]
moya db sync
[/code]

When you run this from the project directory, Moya will extract all the [tag]model[/tag] tags from your project and create the table(s) in the database. The name of the table in the database is generated from the name of the application and the name of the model. A model's name is assumed to be the same as the [c]libname[/c] in lower case, except if you explicitly supply the [c]name[/c] parameter, which is used in preference. So if the preceding example was in an application called [c]moya[/c], the table name would be [c]moya_character[/c].

[h2]Fields[/h2]

To add a field to a table, simply specify it inside a [tag db]model[/tag]. There are a number of fields to store different types of information. We've seen the [tag db]string[/tag] tag which adds string of a specific length to a model. There are other fields to store different types of data, such as numbers, text, dates etc. Other field types define how tables [i]relate[/i] to each other.

[h2]Model References[/h2]

Models are referenced in Moya code the same way as other elements. The preceding example had a libname of [c]Character[/c] and may be referenced with [c]#Character[/c] -- from the same library. If you want to reference a model from another library then you need to precede the [c]#[/c] with the name of the application. For example, if the [c]#Character[/c] is in an application called [c]moya[/c], it may be referenced as [c]moya#Character[/c]. You can also use the library long name in place of the application [i]if[/i] the library is installed just once.

[h2]Creating Model Objects[/h2]

You can create an object in the database with the [tag db]create[/tag] tag. The model is specified in the [c]model[/c] attribute. The fields are specified in the same way as a data setter tag (e.g. [tag]dict[/tag]). The following code adds a new [i]character[/i] to the database:

[code xml]
<db:create model="#Character" dst="character">
    <str dst="name">John</str>
    <str dst="species">Human</str>
</db:create>
[/code]

You may also use the LET extension to specify the field data as follows:

[code xml]
<db:create model="#Character" dst="character"
    let:name="John" let:species="Human"/>
[/code]

When the [tag db]create[/tag] runs it stores a model object in the value specified in [c]dst[/c]. You can access the fields of a model object, in the same way as any other data. For example:

[code xml]
<echo>${character.name} is a ${character.species}</echo>
[/code]

Models also have an implicit field called [c]id[/c] which is the [i]primary[/i] key. This value starts at [c]1[/c] and increments every time you create a new model object. i.e. the first [c]Character[/c] will have an id of [c]1[/c], the second will have id [c]2[/c] etc.

You can access this field as any other in the model. But if you were to refer to [c]character.id[/c] immediately after creating it, you would find the value to be [c]None[/c]. This is because the new character has not yet been [i]inserted[/i] in to the database. Generally Moya inserts new objects at the end of the request. If you do need the [c]id[/c] value at the point you create the object, you can force new objects to be inserted immediately with [tag db]commit[/tag]. For example:

[code xml]
<db:create model="#Character" dst="character"
    let:name="John" let:species="Human"/>
<echo>${character.name} is a ${character.species}</echo>
<db:commit/>
<echo>id is ${character.id}</echo>
[/code]

[h2]Common Field Attributes[/h2]

There are some common attributes used by database [link db#field-reference]field tags[/link] that have the same meaning.

The [c]null[/c] attribute is a boolean which allows the use of a [c]NULL[/c] value in the database column. A value of [c]NULL[/c] translates as [c]None[/c] in Moya and is generally used to indicate [i]not applicable[/i] or [i]no value[/i] in a database object.

The [c]default[/c] attribute sets the value used if no value is given when the object is created.

The [c]unique[/c] attribute is a boolean which tells Moya to impose a [i]unique[/i] constraint on the database table. This means that if you try to create an object with a field the same as an existing object, Moya will raise a [c]db.integrity-error[/c] exception.

The [c]label[/c] attribute should be the human readable name of the field, and [c]help[/c] should be a one-sentence description of the field purpose. Both are optional and used when builing forms to create / edit a model object.

[h2]Unique Fields[/h2]

The [c]unique[/c] attribute on a field tag ensures that the particular value will appear exactly once in the table. let's look at a model with a unique field:

[code xml]
<model libname="Ship" repr="ship ${name}" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" unique="yes" null="no" />
    <string name="type" length="30" null="no" />
</model>
[/code]

We can create a [c]#Ship[/c] object with the following:

[code xml]
<db:create model="#Ship" let:name="Moya" let:type="Leviathan" />
[/code]

Because the [c]name[/c] field has [c]unique="yes"[/c], if we try to create another ship with the same name, Moya will raise a [c]db.integrity-error[/c] exception. For example, the follow code will detect the exception:

[code xml]
<db:create model="#Ship" let:name="Moya" let:type="Command Carrier" />
<catch exception="db.integrity-error">
    <echo>A ship of that name already exists!</echo>
</catch>
[/code]

It is also possible to apply a unique restraint to a group of fields with the [tag db]unique-together[/tag]. The following applies a unique restraint to [c]name[/c] and [c]type[/c]:

[code xml]
<model libname="Ship" repr="ship ${name}" xmlns="http://moyaproject.com/db">
    <unique-together>
        <string name="name" length="30" null="no" />
        <string name="type" length="30" null="no" />
    </unique-together>
    <text name="description" null="no" default=""/>
</model>
[/code]

This code ensures that the [i]combination[/i] of [c]name[/c] and [c]type[/c] is unique -- so there could only be one ship with name [c]Moya[/c] [i]and[/i] type [c]leviathan[/c], but potentially other ships called [c]Moya[/c] with a different [c]type[/c].

[h2]Foreign Keys[/h2]

A [i]foreign key[/i] is a link from one model to another. Let's add a foreign key field to the Character model which links to a Ship model. Here are new models:

[code xml]
<model libname="Ship" repr="ship ${name}" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" unique="yes" null="no" />
    <string name="type" length="30" null="no" />
</model>

<model libname="Character" repr="character ${name}" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" null="no"/>
    <string name="species" length="20" null="no" default="human" />
    <foreign-key name="ship" model="#Ship" null="yes" />
</model>
[/code]

Now Character model objects will have the attribute [c]ship[/c], which may be set to [c]None[/c] or to a ship model. This is demonstrated by the following code which creates a Ship and a Character model:

[code xml]
<db:create model="#Ship" dst="moya"
    let:name="'Moya'" let:type="'Leviathan'" />

<db:create model="#Character" dst="john"
    let:name="'John'" let:species="'human'"
    let:ship="moya"/>
[/code]

With the [c]ship[/c] attribute set, you can now refer to the character's ship as [c]john.ship[/c], and it's attributes (e.g. [c]john.ship.name[/c]).

[h3]Backrefs[/h3]

We've seen that the foreign key has created a link from a Character to a Ship. It also possible to establish a link in the [i]reverse[/i] direction with the [c]backref[/c] attribute. Let's revise the Character model to add a backref:

[code xml]
<model libname="Character" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" null="no"/>
    <string name="species" length="20" null="no" default="human" />
    <foreign-key name="ship" model="#Ship" null="yes" backref="characters"/>
</model>
[/code]

The addition of the [c]backref[/c] attribute (on Character) has created an attribute called [c]characters[/c] on the Ship model. This attribute is a [i]list[/i] of all the Character objects that have a foreign key to that ship. Here's how you could list all characters for a ship:

[code xml]
<for src="ship.characters" dst="character">
    <echo>${character} is on board ${ship}
</for>
[/code]

[h3]One to One[/h3]

A variation of the foreign key is a [i]one to one[/i], which establishes a foreign key relationship where there is only ever one link. For example, if we had used a one-to-one rather than a foreign key on the the Character model, then a ship have at most one associated character.

This is reflected in the [c]backref[/c] attribute which creates a link rather than a list. Let's look at what would happen if we made the [c]ship[/c] foreign key a one-to-one:

[code xml]
<model libname="Character" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" null="no"/>
    <string name="species" length="20" null="no" default="human" />
    <one-to-one name="ship" model="#Ship" null="yes" backref="character"/>
</model>
[/code]

Here we have changed the [tag db]foreign-key[/tag] tag to a [tag db]one-to-one[/tag] tag. We've also changed the value of the [c]backref[/c] attribute from [c]characters[/c] to [c]character[/c]. The result is that we can access the ship from the character with [c]character.ship[/c] and also access the character from the ship with [c]ship.character[/c].

[aside]You could do [b]character.ship.character.ship[/b], but that would be madness.[/aside]

[h2]Model Relationships[/h2]

We've seen that when you add a foreign key to a model, you can also create a list on the object referenced by the foreign key that represents the reverse side of the foreign key (via the [c]backref[/c] attribute). This is an example of a model [i]relationship[/i]. Moya supports a variety of other ways to establish such relationships that reflect how your models relate to each other.

[h2]Many to Many[/h2]

A [i]many to many[/i] relationship is where two models share a relationship. So if we have two models, A and B; then an A object may be associated with any number of B objects, and B objects may be associated with any number of A objects.

Lets look at more tangible example to demonstrate this. Our Character model has a [c]species[/c] attribute which is a string. This will limit us if we want to store some information about the species, such as the planet of origin. Let's define a Species model for more flexibility:

[code xml]
<model libname="Species" repr="species ${name}" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" null="no"/>
    <string name="planet" length="20" null="no" />
</model>
[/code]

We can add a few Species objects with the following:

[code xml]
<db:create model="#Species" let:name="'Human'" let:planet="'Earth'" dst="human" />
<db:create model="#Species" let:name="'Sebaccean'" let:planet="various" dst="sebacean"/>
<db:create model="#Species" let:name="'Luxan'" let:planet="'Luxan terratories'" dst="luxan" />
[/code]

Naturally, a [i]species[/i] may have any number of [i]characters[/i]. And a character will belong to [i]at least[/i] one species -- more in the case of hybrids. This can be represented in the model with a [tag db]many-to-many[/tag] tag, which may be added to either side of the relationship (character or species) but lets replace the species field on Character:

[code xml]
<model libname="Character" repr="character ${name}" xmlns="http://moyaproject.com/db">
    <string name="name" length="30" null="no"/>
    <many-to-many name="species" model="#Species"/>
</model>
[/code]

Now when we create a character, we will have a [c]species[/c] attribute which is a [i]list[/i] of Species objects. Let's create a character with one species:

[code xml]
<db:create model="#Character" let:name="'John'" dst="john"/>
<append src="john.species" value="human" />
<echo>${john.species}</echo>
[/code]

Here we have created a Character called John, and associated him with the previously created [c]human[/c] species by appending to the [c]species[/c] list. We can create a hybrid character by adding more than one Species. Here's an example of creating a character that is half [i]Sebaccean[/i] and half [i]Luxan[/i]:

[code xml]
<db:create model="#Character" let:name="'Jothee'" dst="jothee" />
<append src="jothee.species" value="Sebaccean" />
<append src="jothee.species" value="luxan" />
<echo>${jothee.species}</echo>
[/code]

To retrieve the reverse side of the relationship, we can add a [c]backref[/c] attribute to the [tag db]many-to-many[/tag]. Let's add a backref to the Species model:

[code xml]
<many-to-many name="species" model="#Species" backref="characters"/>
[/code]

Now we can view all characters for a given species via a [c]characters[/c] attribute. Here's how we can list all the Humans in the database:

[code xml]
<for src="human.characters" dst="character">
    <echo>${character} is a human</echo?
</for>
[/code]

[h1]Getting Model Objects[/h1]

You can retrieve an object from the database with [tag db]get[/tag], which queries (looks up) the database for an object with matching fields. Here's how you could retrieve the object inserted with [tag db]create[/tag]:

[code xml]
<db:get model="#Character" dst="character">
    <str dst="name">John</str>
</db:get>
<echo>John is a ${character.species}</echo>
[/code]

This finds the [c]#Character[/c] with a value of [c]name[/c] set to [c]John[/c]. You can also use the LET extension to specify fields, as follows:

[code xml]
<db:get model="#Character" dst="character" let:name="John"/>
[/code]

If there is no matching object in the database, then [tag db]get[/tag] will store the value of [c]None[/c] in [c]dst[/c]. You can use this to determine if an object exists or not as follows:

[code xml]
<db:get model="#Character" dst="character" let:name="Will"/>
<echo if="character is None">I don't know what species Will is</echo>
[/code]

If there are more than one matching object in the database then Moya will return one of them. Normally, you won't be able to know in advance which object will be returned, but if you specify the [c]orderby[/c] attribute, Moya will sort the results by this field and return the first one. For instance, lets get a character that has a [c]species[/c] of [c]Human[/c]:

[code xml]
<db:get model="#Character" dst="character" let:species="Human" orderby="name" />
[/code]

If there is more than one Human in the database, Moya will return the character with a name that comes first in alphabetical order.

[h2]Getting Exactly One[/h2]

An alternative to [tag db]get[/tag] which assumes there is exactly one result is [tag db]get-one[/tag]. This tag works like [tag db]get[/tag], but will throw an exception if there are no results (rather than return [c]None[/c]). It will also throw an exception if there are [i]multiple[/i] results. Here's an example:

[code xml]
<db:get model="#Character" dst="character" let:species="Human" let:name="Rygel" />
<catch exception="db.no-result">
    <echo>No Humans called Rygel!</echo>
</catch>
<catch exception="db-multiple-results">
    <echo>There are multiple humans called Rygel!</echo>
</catch>
[/code]

This will attempt to find exactly one Human called Rygel, and will handle the case where there are None, or more than one.

The tags [tag db]get[/tag] and [tag db]get-one[/tag] are often interchangeable, but [tag db]get-one[/tag] is useful for catching errors in your database, which might otherwise produce unexpected results

[h2]Get Required[/h2]

It is a fairly frequent requirement to get a database object which will be used to generate a page (a blog post for example). In these cases you would want to display a 404 (not found) page if the object [i]does not[/i] exists. For example, lets say we have a page for each character in our database and the url [link urls#url-routes]route[/link] is [c]/character/{name}/[/c]. The view would do the following to look up a character:

[code xml]
<db:get model="#Character" let:name="url.name" dst="character"/>
<not-found if="not character" />
[/code]

If you were to visit a url such as [c]/character/will/[/c] (and there is no character called [c]will[/c]), then [c]character[/c] will be [c]None[/c] and the following line will return the 404 response.

This code can be simplified with [tag db]get-required[/tag] which works like [tag db]get[/tag], but will return the not found response automatically if the object does not exist. Here's how we could re-write the above code:

[code xml]
<db:get-required model="#Character" let:name="url.name" dst="character" />
[/code]

[h1]Modifying Model Objects[/h1]

Once you have a model object, you may make changes simply by setting the attributes. For example, the following code retrieves an object then modifies an attribute:

[code xml]
<db:get model="#Character" let:name="John" dst="john" />
<let john.species="Hynerian" />
[/code]

This will issue an [i]update[/i] to the database to modify the [c]species[/c] column and turn John in to a Hynerian. The changes may not be made permanent until the next commit (see [link db#transactions]Transactions[/link]). You can force Moya to modify the database object immediately with the [tag db]commit[/tag] tag.

[h1]Queries[/h1]

For more sophisticated [i]querying[/i], especially where you need to retrieve more than one object, Moya offers the [tag db]query[/tag] tag. Let's look at a very simple use of this tag:

[code xml]
<query model="#Character" dst="characters" />
[/code]

This line of code returns a [i]queryset[/i], which is an object that represents the results of a query. In this case, the queryset will give us all Character objects in the database.

When the queryset is created, Moya has not yet retrieved any results from the database. To actually get the results from a queryset you can [i]iterate[/i] over it, in Moya Code or a template. Here's how you might display the results of the previous query:

[code xml]
<for src="characters" dst="character">
    <echo>${character.name} is a ${character.species}
</for>
[/code]

Alternatively, Moya querysets have a few attributes which can return results or other information regarding the queryset. You can retrieve the first result in the query with [c]queryset.first[/c], the total number of results can be retrieved with [c]queryset.count[/c], a boolean that indicates if there are at least one result may be retrieved with [c]queryset.exists[/c], and the queryset can be retrieved as a list with [c]queryset.list[/c]. The following code demonstrates how to use some of those queryset attributes:

[code xml]
<db:query model="#Character" dst="characters" />
<echo>${characters.count} result(s)</echo>
<echo>First result: ${characters.first}</echo>
<echo obj="characters.list" />
[/code]

[h2]Filtering Queries[/h2]

As well as retrieving [i]all[/i] objects stored in the database, you can also [i]filter[/i] results with the [c]filter[/c] attribute, which takes a [i]database expression[/i]. Data expressions look similar to the expressions used elsewhere in Moya, but are converted to SQL.

The following example retrieves all Characters with the name of [c]John[/c]:

[code xml]
<db:query model="#Character" filter="#Character.name == 'John'" dst="johns" />
[/code]

The filter attribute [c]#Character.name == 'John'[/c] tells Moya to filter results with the [c]name[/c] column of [c]#Character[/c] set to [c]'John'[/c]. Database expressions can also express more sophisticated conditions with multiple fields. See the [link db#database-expressions]Database Expressions[/link] section for the full details.

[h2]Sorting Querysets[/h2]

The [tag db]query[/tag] tag can also sort results by a field on the model. You can specify the field to sort on with the [c]orderby[/c] field. Here's an example that sorts the Characters by [i]name[/i]:

[code xml]
<db:query model="#Character" dst="characters" orderby="name"/>
[/code]

By default, queries are sorted in ascending order (A->Z for string fields). You can specify [i]descending[/i] order (Z->A) in one of two ways; you can either precede the [c]orderby[/c] attribute with a hyphen, or set the [c]reverse[/c] field to [c]yes[/c]. The following two lines are equivalent:

[code xml]
<db:query model="#Character" dst="characters" orderby="-name"/>
[/code]

[code xml]
<db:query model="#Character" dst="characters" orderby="name" reverse="yes"/>
[/code]

You can sort by more than one field by listing them in the [c]orderby[/c] attribute separated by commas. For example, the following sorts first by the [c]name[/c] field, then the [c]species[/c] field:

[code xml]
<db:query model="#Character" dst="characters" orderby="name,species"/>
[/code]

[h2]Querying Columns[/h2]

Sometimes you only need to retrieve a few columns from each object, rather than the entire object. For these situations you can omit the [c]model[/c] attribute, and specify the fields you are interested in with the [c]columns[/c] attribute. For example, the following will retrieve just the names of the Characters:

[code xml]
<db:query columns="#Character.name,#Character.species" dst="characters" />
<echo obj="characters.list" />
[/code]

The above code will return a list of fields for each result. For example if there is one result it would return something like the following:

[code]
[['John', 'Human']]
[/code]

If you are only interested in a single column in a queryset you can specify the [c]flat[/c] attribute which tells Moya to return a list of columns rather than a list of lists. Here's an example:

[code xml]
<db:query columns="#Character.name" flat="yes" dst="characters" />
[/code]

This will return something like the following:

[code]
['John']
[/code]

[alert]
Note that when you retrieve columns, you won't be able to make persistent changes by modifying the results.
[/alert]

[h2]Limiting Results[/h2]

You can specify a range of results to return with the [c]start[/c] and [c]maxresults[/c] attributes; [c]start[/c] is the index of the first result you want to retrieve, and [c]maxresults[/c] is the maximum number of results you want to retrieve. You may want to do this if you are paginating results, for example.

Here's how you might retrieve a [i]page[/i] of results:

[code xml]
<db:query model="#Character" start="(page - 1) * 10" maxresults="10" dst="characters" />
[/code]

The above assumes a variable called [c]page[/c] which should be a page number (starting from 1), and 10 results per page.

[h2]Refining Queries[/h2]

It is possible to take an existing queryset object and further refine it. This is occasionally useful for more complex queries that can be simplified in to a number of steps. You can do this by suppling a queryset with the [c]src[/c] attribute.

For example, the following performs a query in two steps:

[code xml]
<db:query model="#Character" filter="#Character.name=='John'" dst="johns"/>
<db:query src="johns" filter="#Character.species=='Human'" dst="human_johns"/>
<echo obj="human_johns.list" />
[/code]

[h2]Updating[/h2]

It is possible to update every object in a queryset with the [tag db]update[/tag] tag. This is more efficient that modifying objects in memory, as the update can happen entirely on the database.

The [tag db]update[/tag] tag has a single attribute, [c]src[/c], which should be the queryset you wish to update. The fields you wish to modify are specified with the LET extension. Here's an example that changes the species field of all human Characters to [c]'Scarran'[/c]

[code xml]
<db:query model="#Character" filter="#Character.species=='Human'" dst="humans" />
<db:update src="humans" let:species=="'Scarran'" />
[/code]

The value of a field may be set with a [link db#database-expressions]database expression[/link], which allows you to refer to multiple fields in the update. The following code, gets a query for all Characters, and updates the [c]species[/c] field to [c]"#Character.species + ' Scarran hybrid'"[/c]:

[code xml]
<db:query model="#Character" dst="characters" />
<db:update src="characters" let:species=="#Character.species + ' Scarran hybrid'" />
[/code]

The result would be the species field being changed to the Characters's species plus [c]' Scarran hybrid'[/c]. Humans, for example, would become [c]Human Scarran hybrid[/c] and Hynerians would begine [c]Hynerian Scarran hybrid[/c].

[h1]Deleting Model Objects[/h1]

You can [i]delete[/i] an object from the database with the [tag db]delete[/tag] tag which takes the object to delete in the [c]src[/c] attribute. Here's how you can delete an object you have previously retrieved:

[code xml]
<db:get model="#Character" let:name="'Rygel'" dst="rygel" />
<db:delete src="rygel" />
[/code]

You can also supply a queryset in the src attribute, which will delete all objects in that queryset. The following code gets a queryset for all human Characters and deletes them:

[code xml]
<db:query model="#Character" let:species="'Human'" dst="humans" />
<db:delete src="humans" />
<echo>Deleted all humans!</echo>
[/code]

[h1]Transactions[/h1]

A [i]transaction[/i] is a database feature that manages when changes to the database are made permanent (this is called [i]commiting[/i]). Up to that point it is also possible to [i]roll back[/i] any changes made to the database, to the state the database was in after the last commit.

Moya's default behavior is to immediately commit changes following database operations such as [tag db]create[/tag], [tag db]update[/tag] etc. Modifications to database objects through setting attributes, are [i]not[/i] committed immediately. Moya will commit any pending changes at the end of a successful request. If there are any un-handled exceptions in the processing of a request, Moya will roll back any pending changes to the last commit, or to the state the database was in at the start of the request.

You can explicitly commit any pending changes with the [tag db]commit[/tag] tag. This will ensure that any modifications made to model objects via setting attributes are written to the database. Here's an example:

[code xml]
<db:get-or-create model="#Character" let:name="'John'" dst="john"/>
<let-str john.description="Bipedal life-form, around 6ft tall"/>
<db:commit/>
[/code]

An alternative way of managing when to commit is via the [tag db]transaction[/tag] tag, which ensures that the any changes made within the enclosed block are committed together if there are no un-handled exceptions. If exceptions are thrown (and not handled) within the transaction, the changes are rolled back. This overrides any tags which would otherwise commit (including [tag db]commit[/tag]), so that everything is committed together.

[aside]Committing a number of db operations in one group can be more efficient than committing them individually.[/aside]

Lets demonstrate the effects of the [tag db]transaction[/tag] tag. First we will modify the Character model slightly to make the [c]name[/c] and [c]species[/c] fields [link db#unique-fields]unique[/link]:

[code xml]
<model libname="Character" repr="character ${name}" xmlns="http://moyaproject.com/db">
    <unique-together>
        <string name="name" length="30" null="no"/>
        <string name="species" length="20" null="no" default="human" />
    </unique-together>
</model>
[/code]

The addition of [tag db]unique-together[/tag] ensures that the database will only let us create one of each name/species combination. If the combination already exists, Moya will throw a [c]db.integrity-error[/c]. The following code will try to do just that:

[code xml]
<db:transaction>
    <db:create model="#Character" let:name="'John'" let:species="'Human'" dst="john"/>
    <db:create model="#Character" let:name="'John'" let:species="'Human'" dst="clone"/>
</db:transactions>
<catch exception="db.integrity-error">
    <echo>Can't clone John!</echo>
</catch>
[/code]

When this code runs, Moya will attempt to create the two model objects in the database. The second [tag db]create[/tag] will fail because of the unique constraint on the model and throw a [c]db.integrity-error[/c]. Because this exception isn't handled inside the [tag db]transaction[/tag], Moya will rollback the pending changes, so that [i]no[/i] new characters are created.

Without the [tag db]transaction[/tag], the first [tag db]create[/tag] would have succeeded in creating a Character.

A disadvantage of the [tag db]transaction[/tag] is that database related exceptions may only be thrown at the end of the [tag db]transactions[/tag]. If you call code that handles db exceptions, it may not function as expected.


[h1]Raw SQL[/h1]

It is possible to execute [i]raw[/i] SQL in Moya. This is generally discouraged, because it is possible to write SQL that doesn't work on all supported databases. Raw SQL is an option, however, if you need to access a feature of your database that Moya doesn't expose.

Use the [tag db]sql[/tag] tag to execute sql. The sql can be bound with parameters with the [c]bind[/c] attribute, which should be a dict or dict-like object. Here is an example of a query with a bound parameter:

[code xml]
<db:sql bind="name='John'" dst="johns">
    select * from moya_characters where name=:name;
</db:sql>
<echo obj="johns.fetch.all" />
[/code]

The query will be executed on the database and Moya will return a [i]results[/i] object. See the [tag db]sql[/tag] documentation for details of results objects.

[aside]Note that the text in the <sql> tag does [i]not[/i] support the usual substitution syntax ([b]${}[/b]). This is intentional because otherwise it would be vulnerable to [url http://en.wikipedia.org/wiki/SQL_injection]SQL injection[/url] attacks.[aside]

[h1]Database Expressions[/h1]

Moya's [i]database expressions[/i] are similar to the [i]context[/i] expressions used elsewhere, but are transformed in to SQL by certain database tags. Since database expressions are evaluated by the database, they only support the range of operations you can do in SQL. This isn't really a restriction, because database expressions can still refer to any value on the context.

[h2]Field References[/h2]

A database expression must contain a [i]field reference[/i] which consists of the model reference followed by a period and the name of the field. For example, [c]#Character.name[/c] references the [c]name[/c] field in the model [c]#Character[/c].

[aside]You can't use the [i]docname[/i] in a field reference, as the [c]#[/c] is required.[/aside]

A field reference may also span relationships. For example, the following is valid:

[code]
#Character.ship.name
[/code]

This would reference the [c]name[/c] field from the [c]ship[/c] foreign key of [c]#Character[/c].

[h2]Literals[/h2]

Database expressions may also contain literals -- strings, numbers, and booleans -- which are written in the same way as context expressions. For example, [c]'Hynerian'[/c], [c]42[/c], [c]yes[/c], [c]no[/c]. A constant of [c]None[/c] means the same as [c]NULL[/c] in database expressions.

[h2]Context References[/h2]

Values in the context are also referenced in the same way as context expressions. For example, [c]foo[/c], [c]character.species[/c], [c].request.path[/c] are all valid in database expressions.

[h2]Operators[/h2]

Field references, literals and context references may be combined with some of the familiar operators. For example, the following expression would find all the [c]#Character[/c] objects with a [c]name[/c] field [i]equal to[/i] [c]'John'[/c].

[code xml]
#Character.name == 'John'
[/code]

The operators [c]==[/c], [c]!=[/c], [c]lt[/c], [c]lte[/c], [c]gt[/c], [c]gte[/c], [c]^=[/c], [c]$=[/c], [c]in[/c], and [c]not in[/c] all work like the equivalent operator in context expressions. Database expressions also support the SQL [url http://en.wikipedia.org/wiki/Where_(SQL)#LIKE]like[/url] operator.

[h2]Parenthesis[/h2]

Database expression support parenthesis (brackets) in the same way as context expressions.

[h2]Logic Operators[/h2]

Parenthesis and the logic operators [c]and[/c] and [c]or[/c] work the same way as context expressions. For example, the following expression would match all [c]#Character[/c] objects with the [c]name[/c] field set to 'John' and [c]species[/c] set to [c]'Human'[/c]:

[code xml]
(#Character.name == 'John') and (#Character.species == 'Human')
[/code]

[h2]Related Fields[/h2]

Database expressions may also refer to relationships with the same dotted notation. For example, the following db expression refers to the [c]name[/c] attribute of foreign key object in #Character:

[code xml]
#Character.ship.name == 'Moya' and #Character.species == 'Human'
[/code]

[h2]Modifiers[/h2]

Database expressions also support the following [c]modifiers[/c] which translate in to SQL. These are typically used when querying columns.

[h3]abs:[/h3]

Returns the [i]absolute[/i] (with the negative sign) value of a number.

[h3]count:[/h3]

Returns the number of rows in a query.

[h3]sum:[/h3]

Sums the valus in a query.

[h3]min:[/h3]

Returns the minimum value in a query.

[h3]max:[/h3]

Returns the maximum value in a query.

[h1]Field Reference[/h1]

The following are the fields you may add to a [tag db]model[/tag]:

[h2]<big-integer>[/h2]

A [i]big[/i] integer is a whole number in the range -9223372036854775808 to 9223372036854775807. See [tag db]big-integer[/tag].

[h2]<boolean>[/h2]

Stores a boolean value, which maps directly to a Moya boolean. See [tag db]boolean[/tag].

[h2]<date>[/h2]

Stores a data (year, month, day). See [tag db]date[/tag].

[h2]<float>[/h2]

Stores a floating point value (number with fractional part). See [tag db]float[/tag]

[h2]<foreign-key>[/h2]

Stores a [i]foreign key[/i] to another model. Foreign keys are a link from one table to another. See [tag db]foreign-key[/tag].

[h2]<integer>[/h2]

Stores an integer (whole number). See [tag db]integer[/tag].

[h2]<many-to-many>[/h2]

Creates a [i]many to many[/i] relationship with another model. See [tag db]many-to-many[/tag].

[h2]<one-to-one>[/h2]

Creates a [i]one to one[/i] relationship with another model. See [tag db]one-to-one[/tag].

[h2]<relationship>[/h2]

Creates a relationship with another model. See [tag db]relationship[/tag].

[h2]<small-integer>[/h2]

Create a [i]small[/i] integer (whole number). See [tag db]small-integer[/tag].

[h2]<string-map>[/h2]

Creates a string map field. See [tag db]string-map[/tag]

[h2]<string>[/h2]

Creates a string field. See [tag db]string[/tag]

[h2]<text>[/h2]

Create a [i]text[/i] field. A text field is similar to a string field, but without a restriction on the size. See [tag db]text[/tag].

[h2]<timezone>[/h2]

Create a field to store a timezone. Used by the Moya Admin application. See [tag db]timezone[/tag].

[h2]<token>[/h2]

Creates a field to store a randomly generated token. See [tag db]token[/tag].

[h2]<uuid>[/h2]

Creates a field to store a [url http://en.wikipedia.org/wiki/Universally_unique_identifier]UUID[/url]. See [tag db]uuid[/tag].

